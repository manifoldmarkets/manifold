-- This file is autogenerated from regen-schema.ts
create
or replace function public.manalink_populate_cols () returns trigger language plpgsql as $function$ begin 
    if new.data is not null then 
        new.from_id := (new.data)->>'fromId';
    end if;
    return new;
end $function$;

create
or replace function public.get_contract_page_views (contract_id text) returns numeric language sql as $function$
  select coalesce(sum(page_views), 0)
  from user_contract_views as ucv
  where ucv.contract_id = get_contract_page_views.contract_id
$function$;

create
or replace function public.get_contract_voters (this_contract_id text) returns table (data json) language sql parallel SAFE as $function$
  SELECT users.data from users join votes on votes.user_id = users.id where votes.contract_id = this_contract_id;
$function$;

create
or replace function public.get_contracts_by_creator_ids (creator_ids text[], created_time bigint) returns table (creator_id text, contracts jsonb) language sql stable parallel SAFE as $function$
select creator_id,
  jsonb_agg(data) as contracts
from contracts
where creator_id = any(creator_ids)
  and contracts.created_time > millis_to_ts($2)
group by creator_id;
$function$;

create
or replace function public.get_contracts_in_group_slugs_1 (
  contract_ids text[],
  p_group_slugs text[],
  ignore_slugs text[]
) returns table (data json, importance_score numeric) language sql stable parallel SAFE as $function$
select data, importance_score
from public_contracts
where id = any(contract_ids)
  and (public_contracts.group_slugs && p_group_slugs)
  and not (public_contracts.group_slugs && ignore_slugs)
$function$;

create
or replace function public.get_donations_by_charity () returns table (
  charity_id text,
  num_supporters bigint,
  total numeric
) language sql as $function$
    select to_id as charity_id,
      count(distinct from_id) as num_supporters,
      sum(case when token = 'M$'
        then amount / 100
        else amount / 1000 end
      ) as total
    from txns
    where category = 'CHARITY'
    group by to_id
    order by total desc
$function$;

create
or replace function public.get_non_empty_private_message_channel_ids (
  p_user_id text,
  p_limit integer default null::integer
) returns table (id bigint) language plpgsql as $function$
BEGIN
    RETURN QUERY
    SELECT pumc.id
    FROM private_user_message_channels pumc
    JOIN private_user_message_channel_members pumcm ON pumcm.channel_id = pumc.id 
    WHERE pumcm.user_id = p_user_id
    AND EXISTS (
        SELECT 1 
        FROM private_user_messages
        WHERE pumc.id = private_user_messages.channel_id
    )
    ORDER BY pumc.last_updated_time DESC
    LIMIT p_limit;
END;
$function$;

create
or replace function public.get_cpmm_resolved_prob (c contracts) returns numeric language sql immutable parallel SAFE as $function$
select case
    when c.data->>'resolution' = 'YES' then 1
    when c.data->>'resolution' = 'NO' then 0
    when c.data ? 'resolutionProbability' then (c.data->'resolutionProbability')::numeric
    else null
end
$function$;

create
or replace function public.can_access_private_messages (channel_id bigint, user_id text) returns boolean language sql parallel SAFE as $function$
select exists (
    select 1 from private_user_message_channel_members
    where private_user_message_channel_members.channel_id = $1
      and private_user_message_channel_members.user_id = $2
)
$function$;

create
or replace function public.calculate_user_profit_for_2023 (user_id_input text) returns numeric language plpgsql as $function$
DECLARE
    total_profit NUMERIC;
BEGIN
    SELECT SUM(profit) INTO total_profit
    FROM public.user_contract_metrics
    WHERE user_id = user_id_input
    AND fs_updated_time >= '2023-01-01'::TIMESTAMPTZ
    AND fs_updated_time < '2024-01-01'::TIMESTAMPTZ;

    RETURN COALESCE(total_profit, 0); -- Return 0 if the sum is NULL
END;
$function$;

create
or replace function public.can_access_private_post (this_post_id text, this_member_id text) returns boolean language sql immutable parallel SAFE as $function$
select exists (
    select 1
    from posts
    join group_members on group_members.group_id = posts.group_id
    where posts.id = this_post_id
      and group_members.member_id = this_member_id
) $function$;

create
or replace function public.get_user_bet_contracts (this_user_id text, this_limit integer) returns table (data json) language sql immutable parallel SAFE as $function$
  select c.data
  from contracts c
  join user_contract_metrics ucm on c.id = ucm.contract_id
  where ucm.user_id = this_user_id
  limit this_limit;
$function$;

create
or replace function public.get_contract_metrics_grouped_by_user_ids (uids text[], period text) returns table (user_id text, contract_metrics jsonb[]) language sql stable parallel SAFE as $function$
select ucm.user_id,
  array_agg(ucm.data) as contract_metrics
from user_contract_metrics as ucm
where ucm.user_id in (
    select unnest(uids)
  )
  and (ucm.data->'from'->period->'profit') is not null
  and abs((ucm.data->'from'->period->'profit')::bigint) > 1
group by ucm.user_id $function$;

create
or replace function public.count_recent_comments (contract_id text) returns integer language sql as $function$
  SELECT COUNT(*)
  FROM contract_comments
  WHERE contract_id = $1
    AND created_time >= NOW() - INTERVAL '1 DAY'
$function$;

create
or replace function public.get_compatibility_questions_with_answer_count () returns setof love_question_with_count_type language plpgsql as $function$
BEGIN
    RETURN QUERY 
    SELECT 
        love_questions.*,
        COUNT(love_compatibility_answers.question_id) as answer_count
    FROM 
        love_questions
    LEFT JOIN 
        love_compatibility_answers ON love_questions.id = love_compatibility_answers.question_id
        WHERE love_questions.answer_type='compatibility_multiple_choice'
    GROUP BY 
        love_questions.id
    ORDER BY 
        answer_count DESC;
END;
$function$;

create
or replace function public.get_average_rating (user_id text) returns numeric language plpgsql as $function$
DECLARE
  result numeric;
BEGIN
  SELECT AVG(rating)::numeric INTO result
  FROM reviews
  WHERE vendor_id = user_id;
  RETURN result;
END;
$function$;

create
or replace function public.count_recent_comments_by_contract () returns table (contract_id text, comment_count integer) language sql as $function$
  SELECT
    contract_id,
    COUNT(*) AS comment_count
  FROM
    contract_comments
  WHERE
    created_time >= NOW() - INTERVAL '1 DAY'
  GROUP BY
    contract_id
  ORDER BY
    comment_count DESC;
$function$;

create
or replace function public.count_users_above_similarity (nid numeric, similarity numeric) returns integer language sql as $function$
WITH title_embedding AS (
  SELECT title_embedding
  FROM news
  WHERE id = nid
),
user_embedding AS (
  SELECT interest_embedding
  FROM user_embeddings
)
SELECT COUNT(*) FROM (
  SELECT
    1 - (title_embedding <=> interest_embedding) AS score
  FROM
    title_embedding
    CROSS JOIN user_embedding
) AS subquery
WHERE score > similarity;
$function$;

create
or replace function public.firebase_uid () returns text language sql stable parallel SAFE leakproof as $function$
  select nullif(current_setting('request.jwt.claims', true)::json->>'sub', '')::text;
$function$;

create
or replace function public.get_contract_metrics_grouped_by_user (uids text[], period text) returns table (user_id text, contract_metrics jsonb[]) language sql immutable parallel SAFE as $function$
select ucm.user_id, array_agg(ucm.data) as contract_metrics
from user_contract_metrics as ucm
where ucm.user_id in (select unnest(uids))
  and (ucm.data->'from'->period->'profit') is not null
    and abs((ucm.data->'from'->period->'profit')::bigint) > 1
group by ucm.user_id
$function$;

create
or replace function public.get_contract_metrics_for_contract (contractid text) returns table (user_id text, contract_metrics jsonb) language sql immutable parallel SAFE as $function$
select ucm.user_id, ucm.data as contract_metrics
from user_contract_metrics as ucm
where ucm.contract_id = contractId
$function$;

create
or replace function public.get_fr_questions_with_answer_count () returns setof love_question_with_count_type language plpgsql as $function$
BEGIN
    RETURN QUERY 
    SELECT 
        love_questions.*,
        COUNT(love_answers.question_id) as answer_count
    FROM 
        love_questions
    LEFT JOIN 
        love_answers ON love_questions.id = love_answers.question_id
        WHERE love_questions.answer_type='free_response'
    GROUP BY 
        love_questions.id
    ORDER BY 
        answer_count DESC;
END;
$function$;

create
or replace function public.get_group_contracts (this_group_id text) returns table (data json) language sql immutable parallel SAFE as $function$
select contracts.data from 
    contracts join group_contracts on group_contracts.contract_id = contracts.id
    where group_contracts.group_id = this_group_id 
    $function$;

create
or replace function public.get_groups_from_user_seen_markets (uid text) returns setof group_with_bet_flag language sql as $function$
-- Groups from user_seen_markets
select (g.id, g.data, false)::group_with_bet_flag
from
    groups g
        join group_contracts gc on g.id = gc.group_id
        join user_seen_markets sm on gc.contract_id = sm.contract_id
where
        sm.user_id = uid
  and sm.type  = 'view market'
union
select (g.id, g.data, true)::group_with_bet_flag
from
    groups g
        join group_contracts gc on g.id = gc.group_id
        join contract_bets cb on gc.contract_id = cb.contract_id
where
        cb.user_id = uid
$function$;

create
or replace function public.get_last_week_long_link (this_group_id text) returns text language sql immutable parallel SAFE as $function$
    SELECT id
    FROM group_invites
    WHERE (
            group_id = this_group_id
            -- just gets the last default link if it was generated less than 12 hours ago
            and duration = '1 week'::interval
            and max_uses is null
            and created_time > (now() - '12 hours'::interval)
        )
    order by created_time desc
    LIMIT 1
$function$;

create
or replace function public.get_monthly_bet_count_and_amount (user_id_input text) returns table (
  month timestamp with time zone,
  bet_count bigint,
  total_amount numeric
) language plpgsql as $function$
BEGIN
    RETURN QUERY
    SELECT
        date_trunc('month', created_time) AS month,
        COUNT(bet_id) AS bet_count,
        SUM(ABS(amount)) AS total_amount  -- Add this line to calculate the sum of amounts
    FROM
        contract_bets
    WHERE
        user_id = user_id_input AND
        created_time >= '2023-01-01' AND
        created_time <= '2024-01-01' AND
        is_ante = false AND
        is_redemption = false
    GROUP BY
        date_trunc('month', created_time)
    ORDER BY
        month;
END;
$function$;

create
or replace function public.get_prefix_match_query (p_query text) returns text language sql immutable as $function$
WITH words AS (
  SELECT unnest(regexp_split_to_array(trim(p_query), E'\\s+')) AS word
),
     numbered_words AS (
       SELECT word, row_number() OVER () AS rn, count(*) OVER () AS total
       FROM words
     )
SELECT string_agg(CASE
                    WHEN rn < total THEN word
                    ELSE word || ':*'
                    END, ' & ')
FROM numbered_words;
$function$;

create
or replace function public.get_open_limit_bets_with_contracts_rls (uid text, count integer) returns table (contract_id text, bets jsonb[], contract jsonb) language sql immutable parallel SAFE as $function$;
select contract_id,
  bets.data as bets,
  contracts.data as contracts
from (
    select contract_id,
      array_agg(
        data
        order by (data->>'createdTime') desc
      ) as data
    from contract_bets
    where (data->>'userId') = uid
      and (data->>'isFilled')::boolean = false
      and (data->>'isCancelled')::boolean = false
    group by contract_id
  ) as bets
  join contracts on contracts.id = bets.contract_id
limit count $function$;

create
or replace function public.get_option_voters (this_contract_id text, this_option_id text) returns table (data json) language sql parallel SAFE as $function$
  SELECT users.data from users join votes on votes.user_id = users.id where votes.contract_id = this_contract_id and votes.id = this_option_id;
$function$;

create
or replace function public.get_profit (portfolio jsonb) returns numeric language sql immutable parallel SAFE as $function$
select ((portfolio->'investmentValue')::numeric +
          (portfolio->'balance')::numeric -
          (portfolio->'totalDeposits')::numeric)
end $function$;

create
or replace function public.get_rating_info (p_vendor_id text) returns table (avg_rating numeric, count bigint) language plpgsql stable as $function$
BEGIN
  RETURN QUERY
    SELECT AVG(rating) AS avg_rating, COUNT(rating) AS count
    FROM reviews
    WHERE vendor_id = p_vendor_id;
END;
$function$;

create
or replace function public.get_recently_active_contracts_in_group_slugs (
  group_slugs text[],
  ignore_slugs text[],
  max integer
) returns table (data json, importance_score numeric) language sql stable parallel SAFE as $function$
select data, importance_score
from public_contracts
where (public_contracts.data -> 'groupSlugs' ?| group_slugs)
  and not (public_contracts.data -> 'groupSlugs' ?| ignore_slugs)
order by ((data->>'lastUpdatedTime')::bigint) desc
limit max
$function$;

create
or replace function public.get_sigmoid_rating (user_id text) returns table (count bigint, rating numeric) language sql immutable parallel SAFE as $function$
  WITH rating_counts AS (
    SELECT AVG(rating) AS avg_rating
    FROM reviews
    WHERE vendor_id = user_id
    GROUP BY reviewer_id
  ), positive_counts AS (
    SELECT 6 + COUNT(*) AS count FROM rating_counts WHERE avg_rating >= 4.0
  ), negative_counts AS (
    SELECT 2 * COUNT(*) AS count FROM rating_counts WHERE avg_rating < 4.0
  ), rating AS (
    SELECT (positive_counts.count + negative_counts.count) AS count,
       (
        -- lower bound of confidence interval: https://www.evanmiller.org/how-not-to-sort-by-average-rating.html
        (positive_counts.count + 1.9208) / (positive_counts.count + negative_counts.count) -
        1.96 * SQRT((positive_counts.count * negative_counts.count) / (positive_counts.count + negative_counts.count) + 0.9604) /
        (positive_counts.count + negative_counts.count)
      ) / (1 + 3.8416 / (positive_counts.count + negative_counts.count)) AS rating
    FROM positive_counts, negative_counts
  )
  SELECT rating.count, 5 / (1 + POW(2.71828, -10*(rating.rating-0.5))) AS rating
  FROM rating;
$function$;

create
or replace function public.get_time () returns bigint language sql stable parallel SAFE as $function$
select ts_to_millis(now())
$function$;

create
or replace function public.get_unique_bettors_since (this_contract_id text, since bigint) returns bigint language sql as $function$
  select count(distinct user_id)
  from contract_bets
  where contract_id = this_contract_id
    and created_time >= millis_to_ts(since);
$function$;

create
or replace function public.get_top_market_ads (uid text, distance_threshold numeric) returns table (
  ad_id text,
  market_id text,
  ad_funds numeric,
  ad_cost_per_view numeric,
  market_data jsonb
) language sql parallel SAFE as $function$
--with all the redeemed ads (has a txn)
with redeemed_ad_ids as (
    select
            data->>'fromId' as fromId
    from
        txns
    where
                data->>'category' = 'MARKET_BOOST_REDEEM'
      and data->>'toId' = uid
),
-- with the user embedding
     user_embedding as (
         select interest_embedding, disinterest_embedding
         from user_embeddings
         where user_id = uid
     ),
--with all the ads that haven't been redeemed, by closest to your embedding
     unredeemed_market_ads as (
         select
             id, market_id, funds, cost_per_view, embedding
         from
             market_ads
         where
                 market_ads.user_id != uid -- hide your own ads; comment out to debug
           and not exists (
             SELECT 1
             FROM redeemed_ad_ids
             WHERE fromId = market_ads.id
         )
           and market_ads.funds >= cost_per_view
           and coalesce(embedding <=> (select disinterest_embedding from user_embedding), 1) > 0.125
           and (embedding <=> (select interest_embedding from user_embedding))  < distance_threshold
         order by cost_per_view * (1 - (embedding <=> (
             select interest_embedding
             from user_embedding
         ))) desc
         limit 50
     ),
--with all the unique market_ids
     unique_market_ids as (
         select distinct market_id
         from unredeemed_market_ads
     ),
--with the top ad for each unique market_id
     top_market_ads as (
         select
             id, market_id, funds, cost_per_view
         from
             unredeemed_market_ads
         where
                 market_id in (select market_id from unique_market_ids)
         order by
                 cost_per_view * (1 - (embedding <=> (select interest_embedding from user_embedding))) desc
         limit
             50
     )
select
    tma.id,
    tma.market_id,
    tma.funds,
    tma.cost_per_view,
    contracts.data
from
    top_market_ads as tma
        inner join contracts on contracts.id = tma.market_id
where
    contracts.resolution_time is null
  and (contracts.close_time > now() or contracts.close_time is null)
$function$;

create
or replace function public.get_user_group_id_for_current_user () returns text language plpgsql as $function$
DECLARE
    user_group_id text;
BEGIN
    SELECT group_id
    INTO user_group_id
    FROM group_members
    WHERE member_id = (auth.uid())::text;

    RETURN user_group_id;
END;
$function$;

create
or replace function public.get_your_contract_ids (uid text, n integer, start integer) returns table (contract_id text) language sql immutable parallel SAFE as $function$
  with your_bet_on_contracts as (
    select contract_id
    from user_contract_metrics
    where user_id = uid
    and (data->'hasShares')::boolean = true
  ), your_liked_contracts as (
    select (data->>'contentId') as contract_id
    from user_reactions
    where user_id = uid
  ), your_followed_contracts as (
    select contract_id
    from contract_follows
    where follow_id = uid
  )
  select contract_id from your_bet_on_contracts
  union
  select contract_id from your_liked_contracts
  union
  select contract_id from your_followed_contracts
  limit n
  offset start
$function$;

create
or replace function public.get_your_contract_ids (uid text) returns table (contract_id text) language sql stable parallel SAFE as $function$ with your_liked_contracts as (
    select content_id as contract_id
    from user_reactions
    where user_id = uid
  ),
  your_followed_contracts as (
    select contract_id
    from contract_follows
    where follow_id = uid
  )
select contract_id
from your_liked_contracts
union
select contract_id
from your_followed_contracts $function$;

create
or replace function public.get_your_daily_changed_contracts (uid text, n integer, start integer) returns table (data jsonb, daily_score real) language sql stable parallel SAFE as $function$
select data,
  coalesce((data->>'dailyScore')::real, 0.0) as daily_score
from get_your_contract_ids(uid)
  left join contracts on contracts.id = contract_id
where contracts.outcome_type = 'BINARY'
order by daily_score desc
limit n offset start $function$;

create
or replace function public.is_group_member (this_group_id text, this_user_id text) returns boolean language sql immutable parallel SAFE as $function$
select EXISTS (
        SELECT 1
        FROM group_members
        WHERE (
                group_id = this_group_id
                and member_id = this_user_id
            )
    ) $function$;

create
or replace function public.is_valid_contract (ct contracts) returns boolean language sql stable parallel SAFE as $function$
select ct.resolution_time is null
           and ct.visibility = 'public'
           and ((ct.close_time > now() + interval '10 minutes') or ct.close_time is null) $function$;

create
or replace function public.is_group_admin (this_group_id text, this_user_id text) returns boolean language sql immutable parallel SAFE as $function$
select EXISTS (
        SELECT 1
        FROM group_members
        WHERE (
                group_id = this_group_id
                and member_id = this_user_id
                and role='admin'
            )
    ) $function$;

create
or replace function public.jsonb_array_to_text_array (_js jsonb) returns text[] language sql immutable parallel SAFE strict as $function$
select array(select jsonb_array_elements_text(_js))
$function$;

create
or replace function public.millis_interval (start_millis bigint, end_millis bigint) returns interval language sql immutable parallel SAFE as $function$
select millis_to_ts(end_millis) - millis_to_ts(start_millis)
$function$;

create
or replace function public.millis_to_ts (millis bigint) returns timestamp with time zone language sql immutable parallel SAFE as $function$
select to_timestamp(millis / 1000.0)
$function$;

create
or replace function public.recently_liked_contract_counts (since bigint) returns table (contract_id text, n integer) language sql stable parallel SAFE as $function$
select content_id as contract_id,
  count(*) as n
from user_reactions
where content_type = 'contract'
  and ts_to_millis(created_time) > since
group by contract_id $function$;

create
or replace function public.sample_resolved_bets (trader_threshold integer, p numeric) returns table (prob numeric, is_yes boolean) language sql stable parallel SAFE as $function$
select  0.5 * ((contract_bets.prob_before)::numeric + (contract_bets.prob_after)::numeric)  as prob, 
       ((contracts.resolution)::text = 'YES')::boolean as is_yes
from contract_bets
  join contracts on contracts.id = contract_bets.contract_id
where 
   contracts.outcome_type = 'BINARY'
  and (contracts.resolution = 'YES' or contracts.resolution = 'NO')
  and contracts.visibility = 'public'
  and (contracts.data->>'uniqueBettorCount')::int >= trader_threshold
  and amount > 0
  and random() < p
$function$;

create
or replace function public.search_contract_embeddings (
  query_embedding vector,
  similarity_threshold double precision,
  match_count integer
) returns table (contract_id text, similarity double precision) language plpgsql as $function$ begin return query
select contract_embeddings.contract_id as contract_id,
  1 - (
    contract_embeddings.embedding <=> query_embedding
  ) as similarity
from contract_embeddings
where 1 - (
    contract_embeddings.embedding <=> query_embedding
  ) > similarity_threshold
order by contract_embeddings.embedding <=> query_embedding
limit match_count;
end;
$function$;

create
or replace function public.save_user_topics_blank_2 (p_user_id text) returns void language sql as $function$
with
    topic_embedding as (
        select avg(embedding) as average
        from topic_embeddings where topic not in
                                    (
                                        select unnest(ARRAY['destiny.gg', 'stock', 'planecrash', 'proofnik', 'permanent', 'personal']::text[])
                                    )
    )
insert into user_topics (user_id, topics, topic_embedding)
values (
           p_user_id,
           ARRAY['']::text[],
           (
               select average
               from topic_embedding
           )
       ) on conflict (user_id) do
    update set topics = excluded.topics,
               topic_embedding = excluded.topic_embedding;
$function$;

create
or replace function public.search_contracts_by_group_slugs_for_creator_1 (
  creator_id text,
  p_group_slugs text[],
  lim integer,
  start integer
) returns jsonb[] language sql stable parallel SAFE as $function$
select array_agg(data)
from (
    select data
    from contracts
    where contracts.group_slugs && p_group_slugs
      and is_valid_contract(contracts)
      and contracts.creator_id = $1
    order by importance_score desc,
      slug offset start
    limit lim
  ) as search_contracts $function$;

create
or replace function public.search_contracts_by_group_slugs_1 (p_group_slugs text[], lim integer, start integer) returns jsonb[] language sql stable parallel SAFE as $function$
select array_agg(data)
from (
    select data
    from contracts
    where contracts.group_slugs && p_group_slugs
      and is_valid_contract(contracts)
    order by importance_score desc,
     slug offset start
    limit lim
  ) as search_contracts $function$;

create
or replace function public.search_groups (query text, count integer) returns setof groups language sql stable as $function$
SELECT *
FROM groups
WHERE groups.name % query
ORDER BY (data->'totalMembers')desc, similarity(query, groups.name) DESC
LIMIT count $function$;

create
or replace function public.ts_to_millis (ts timestamp with time zone) returns bigint language sql immutable parallel SAFE as $function$
select (extract(epoch from ts) * 1000)::bigint
$function$;

create
or replace function public.to_jsonb (jsonb) returns jsonb language sql immutable parallel SAFE strict as $function$ select $1 $function$;

create
or replace function public.top_news (uid text, similarity numeric) returns table (title text, description text) language sql as $function$
with 
user_embedding as (
  select interest_embedding
  from user_embeddings
  where user_id = uid
)
  SELECT
    title, description
  FROM
    news
  where
    1 - (title_embedding <=> (select interest_embedding from user_embedding)) > similarity
  ORDER BY published_time DESC
  LIMIT 10;
$function$;

create
or replace function public.top_news (uid text, similarity numeric, n numeric) returns table (title text, description text) language sql as $function$
with 
user_embedding as (
  select interest_embedding
  from user_embeddings
  where user_id = uid
)
  SELECT
    title, description
  FROM
    news
  where
    1 - (title_embedding <=> (select interest_embedding from user_embedding)) > similarity
  ORDER BY published_time DESC
  LIMIT n;
$function$;

create
or replace function public.ts_to_millis (ts timestamp without time zone) returns bigint language sql immutable parallel SAFE as $function$
select extract(epoch from ts)::bigint * 1000
$function$;

create
or replace function public.user_seen_market_populate_cols () returns trigger language plpgsql as $function$ begin
    if new.data is not null then
        new.is_promoted := ((new.data)->'isPromoted')::boolean;
    end if;
    return new;
end $function$;

create
or replace function public.add_creator_name_to_description (data jsonb) returns text language sql immutable as $function$
select * from CONCAT_WS(
        ' '::text,
        data->>'creatorName',
        extract_text_from_rich_text_json(data->'description')
    )
$function$;

create
or replace function public.calculate_earth_distance_km (
  lat1 double precision,
  lon1 double precision,
  lat2 double precision,
  lon2 double precision
) returns double precision language plpgsql immutable as $function$
DECLARE
  radius_earth_km CONSTANT FLOAT := 6371;
  delta_lat FLOAT;
  delta_lon FLOAT;
  a FLOAT;
  c FLOAT;
BEGIN
  -- Convert degrees to radians
  lat1 := RADIANS(lat1);
  lon1 := RADIANS(lon1);
  lat2 := RADIANS(lat2);
  lon2 := RADIANS(lon2);

  -- Calculate differences
  delta_lat := lat2 - lat1;
  delta_lon := lon2 - lon1;

  -- Apply Haversine formula
  a := SIN(delta_lat / 2) ^ 2 + COS(lat1) * COS(lat2) * SIN(delta_lon / 2) ^ 2;
  c := 2 * ATAN2(SQRT(a), SQRT(1 - a));

  -- Calculate distance
  RETURN radius_earth_km * c;
END;
$function$;

create
or replace function public.close_contract_embeddings (
  input_contract_id text,
  similarity_threshold double precision,
  match_count integer
) returns table (
  contract_id text,
  similarity double precision,
  data jsonb
) language sql as $function$ WITH embedding AS (
    SELECT embedding
    FROM contract_embeddings
    WHERE contract_id = input_contract_id
)
    SELECT contract_id,
           similarity,
           data
    FROM search_contract_embeddings(
                 (
                     SELECT embedding
                     FROM embedding
                 ),
                 similarity_threshold,
                 match_count + 500
         )
             join contracts on contract_id = contracts.id
    where contract_id != input_contract_id
      and resolution_time is null
      and contracts.visibility = 'public'
    order by similarity * similarity * importance_score desc
    limit match_count;
$function$;

create
or replace function public.extract_text_from_rich_text_json (description jsonb) returns text language sql immutable as $function$
WITH RECURSIVE content_elements AS (
    SELECT jsonb_array_elements(description->'content') AS element
    WHERE jsonb_typeof(description) = 'object'
    UNION ALL
    SELECT jsonb_array_elements(element->'content')
    FROM content_elements
    WHERE element->>'type' = 'paragraph' AND element->'content' IS NOT NULL
),
               text_elements AS (
                   SELECT jsonb_array_elements(element->'content') AS text_element
                   FROM content_elements
                   WHERE element->>'type' = 'paragraph'
               ),
               filtered_text_elements AS (
                   SELECT text_element
                   FROM text_elements
                   WHERE jsonb_typeof(text_element) = 'object' AND text_element->>'type' = 'text'
               ),
               all_text_elements AS (
                   SELECT filtered_text_elements.text_element->>'text' AS text
                   FROM filtered_text_elements
               )
SELECT
    CASE
        WHEN jsonb_typeof(description) = 'string' THEN description::text
        ELSE COALESCE(string_agg(all_text_elements.text, ' '), '')
        END
FROM
    all_text_elements;
$function$;

create
or replace function public.get_contract_metrics_with_contracts (uid text, count integer) returns table (contract_id text, metrics jsonb, contract jsonb) language sql immutable parallel SAFE as $function$
select ucm.contract_id, ucm.data as metrics, c.data as contract
from user_contract_metrics as ucm
join contracts as c on c.id = ucm.contract_id
where ucm.user_id = uid
order by ((ucm.data)->'lastBetTime')::bigint desc
limit count
$function$;

create
or replace function public.get_contracts_in_group_slugs (
  contract_ids text[],
  group_slugs text[],
  ignore_slugs text[]
) returns table (data json, importance_score numeric) language sql stable parallel SAFE as $function$
select data, importance_score
from public_contracts
where id = any(contract_ids)
  and (public_contracts.data -> 'groupSlugs' ?| group_slugs)
  and not (public_contracts.data -> 'groupSlugs' ?| ignore_slugs)
$function$;

create
or replace function public.get_cpmm_pool_prob (pool jsonb, p numeric) returns numeric language plpgsql immutable parallel SAFE as $function$
declare
    p_no numeric := (pool->>'NO')::numeric;
    p_yes numeric := (pool->>'YES')::numeric;
    no_weight numeric := p * p_no;
    yes_weight numeric := (1 - p) * p_yes + p * p_no;
begin
    return case when yes_weight = 0 then 1 else (no_weight / yes_weight) end;
end
$function$;

create
or replace function public.get_cpmm_resolved_prob (data jsonb) returns numeric language sql immutable parallel SAFE as $function$
select case
    when data->>'resolution' = 'YES' then 1
    when data->>'resolution' = 'NO' then 0
    when data->>'resolution' = 'MKT' and data ? 'resolutionProbability' then (data->'resolutionProbability')::numeric
    else null
end
$function$;

create
or replace function public.profit_rank (
  uid text,
  excluded_ids text[] default array[]::text[]
) returns integer language sql stable parallel SAFE as $function$
select count(*) + 1
from user_portfolio_history_latest
where not user_id = any(excluded_ids)
  and coalesce(profit ,balance + spice_balance + investment_value - total_deposits) > (
    select coalesce(u.profit, balance + spice_balance + investment_value - total_deposits)
    from user_portfolio_history_latest u
    where u.user_id = uid
)
$function$;

create
or replace function public.get_contract_metrics_with_contracts (uid text, count integer, start integer) returns table (contract_id text, metrics jsonb, contract jsonb) language sql stable as $function$select ucm.contract_id,
       ucm.data as metrics,
       c.data as contract
from user_contract_metrics as ucm
         join contracts as c on c.id = ucm.contract_id
where ucm.user_id = uid
  and ucm.data->'lastBetTime' is not null
  and ucm.answer_id is null
order by ((ucm.data)->'lastBetTime')::bigint desc offset start
    limit count$function$;

create
or replace function public.get_daily_claimed_boosts (user_id text) returns table (total numeric) language sql as $function$
with daily_totals as (
    select
        SUM(t.amount) as total
    from txns t
    where t.created_time > now() - interval '1 day'
      and t.category = 'MARKET_BOOST_REDEEM'
      and t.to_id = user_id
    group by date_trunc('day', t.created_time)
)
select total from daily_totals
order by total desc;
$function$;

create
or replace function public.creator_rank (uid text) returns integer language sql stable parallel SAFE as $function$
  select count(*) + 1
  from users
  where data->'creatorTraders'->'allTime' > (select data->'creatorTraders'->'allTime' from users where id = uid)
$function$;

create
or replace function public.get_engaged_users () returns table (user_id text, username text, name text) language sql stable as $function$
  WITH recent_bettors AS (
      SELECT user_id, date_trunc('week', created_time) AS week
      FROM contract_bets
      WHERE created_time > NOW() - INTERVAL '3 weeks'
  ),
   recent_commentors AS (
       SELECT user_id, date_trunc('week', created_time) AS week
       FROM contract_comments
       WHERE created_time > NOW() - INTERVAL '3 weeks'
   ),
   recent_contractors AS (
       SELECT creator_id AS user_id, date_trunc('week', created_time) AS week
       FROM contracts
       WHERE created_time > NOW() - INTERVAL '3 weeks'
   ),
   weekly_activity_counts AS (
       SELECT user_id, week, COUNT(*) AS activity_count
       FROM (
                SELECT * FROM recent_bettors
                UNION ALL
                SELECT * FROM recent_commentors
                UNION ALL
                SELECT * FROM recent_contractors
            ) all_activities
       GROUP BY user_id, week
   )

  SELECT u.id, u.username, u.name
  FROM users u
  WHERE u.id IN (
      SELECT user_id
      FROM weekly_activity_counts
      GROUP BY user_id
      -- Must have at least 2 actions for at least 3 of the past 3 + current weeks
      HAVING COUNT(*) >= 3 AND MIN(activity_count) >= 2
  )
$function$;

create
or replace function public.get_exact_match_minus_last_word_query (p_query text) returns text language sql immutable as $function$
WITH words AS (
  SELECT unnest(regexp_split_to_array(trim(p_query), E'\\s+')) AS word
),
     numbered_words AS (
       SELECT word, row_number() OVER () AS rn, count(*) OVER () AS total
       FROM words
     )
SELECT string_agg(word, ' & ')
FROM numbered_words
WHERE rn < total
$function$;

create
or replace function public.get_groups_and_scores_from_user_seen_markets (uid text) returns setof group_with_score_and_bet_flag language sql as $function$
select (g.id, g.data, g.importance_score, false)::group_with_score_and_bet_flag
from
    groups g
        join group_contracts gc on g.id = gc.group_id
        join user_contract_views ucv on gc.contract_id = ucv.contract_id
  where ucv.user_id = uid and ucv.page_views > 0
union
select (g.id, g.data, g.importance_score, true)::group_with_score_and_bet_flag
from
    groups g
        join group_contracts gc on g.id = gc.group_id
        join contract_bets cb on gc.contract_id = cb.contract_id
where cb.user_id = uid
$function$;

create
or replace function public.get_love_question_answers_and_lovers (p_question_id bigint) returns setof other_lover_answers_type language plpgsql as $function$
BEGIN
    RETURN QUERY
    SELECT 
        love_answers.question_id,
        love_answers.created_time,
        love_answers.free_response,
        love_answers.multiple_choice,
        love_answers.integer,
        lovers.age,
        lovers.gender,
        lovers.city,
        users.data
    FROM
        lovers
    JOIN
        love_answers ON lovers.user_id = love_answers.creator_id
    join 
        users on lovers.user_id = users.id 
    WHERE
        love_answers.question_id = p_question_id
    order by love_answers.created_time desc;
END;
$function$;

create
or replace function public.creator_leaderboard (limit_n integer) returns table (
  user_id text,
  total_traders integer,
  name text,
  username text,
  avatar_url text
) language sql stable parallel SAFE as $function$
  select id as user_id, (data->'creatorTraders'->'allTime')::int as total_traders, name, username, data->>'avatarUrl' as avatar_url
  from users
  order by total_traders desc
  limit limit_n
$function$;

create
or replace function public.get_market_ads (uid text) returns table (
  ad_id text,
  market_id text,
  ad_funds numeric,
  ad_cost_per_view numeric,
  market_data jsonb
) language sql as $function$
--with all the redeemed ads (has a txn)
with redeemed_ad_ids as (
  select
    from_id
  from
    txns
  where
    category = 'MARKET_BOOST_REDEEM'
    and to_id = uid
),
-- with the user embedding
user_embedding as (
    select interest_embedding, disinterest_embedding
    from user_embeddings
  where user_id = uid
),
--with all the ads that haven't been redeemed, by closest to your embedding
unredeemed_market_ads as (
  select
    id, market_id, funds, cost_per_view, embedding
  from
    market_ads
  where 
    market_ads.user_id != uid -- hide your own ads; comment out to debug
    and not exists (
      SELECT 1
      FROM redeemed_ad_ids
      WHERE from_id = market_ads.id
    )
    and market_ads.funds >= cost_per_view
    and coalesce(embedding <=> (select disinterest_embedding from user_embedding), 1) > 0.125
    order by cost_per_view * (1 - (embedding <=> (
    select interest_embedding
    from user_embedding
  ))) desc
  limit 50
),
--with all the unique market_ids
unique_market_ids as (
  select distinct market_id
  from unredeemed_market_ads
),
--with the top ad for each unique market_id
top_market_ads as (
  select
    id, market_id, funds, cost_per_view
  from
    unredeemed_market_ads
  where
    market_id in (select market_id from unique_market_ids)
  order by
    cost_per_view * (1 - (embedding <=> (select interest_embedding from user_embedding))) desc
  limit
    50
)
select
  tma.id,
  tma.market_id,
  tma.funds,
  tma.cost_per_view,
  contracts.data
from
  top_market_ads as tma
  inner join contracts on contracts.id = tma.market_id
where
  contracts.resolution_time is null
  and contracts.visibility = 'public'
  and (contracts.close_time > now() or contracts.close_time is null)
$function$;

create
or replace function public.get_non_empty_private_message_channel_ids (
  p_user_id text,
  p_ignored_statuses text[],
  p_limit integer
) returns setof private_user_message_channels language sql as $function$
select distinct pumc.*
from private_user_message_channels pumc
         join private_user_message_channel_members pumcm on pumcm.channel_id = pumc.id
         left join private_user_messages pum on pumc.id = pum.channel_id
    and (pum.visibility != 'introduction' or pum.user_id != p_user_id)
where pumcm.user_id = p_user_id
  and pumcm.status not in (select unnest(p_ignored_statuses))
  and pum.id is not null
order by pumc.last_updated_time desc
limit p_limit;
$function$;

create
or replace function public.get_open_limit_bets_with_contracts (uid text, count integer) returns table (contract_id text, bets jsonb[], contract jsonb) language sql stable parallel SAFE as $function$;
select contract_id,
  bets.data as bets,
  contracts.data as contracts
from (
    select contract_id,
      array_agg(
        data
        order by created_time desc
      ) as data
    from contract_bets
    where user_id = uid
      and (data->>'isFilled')::boolean = false
      and (data->>'isCancelled')::boolean = false
    group by contract_id
  ) as bets
  join contracts on contracts.id = bets.contract_id
limit count $function$;

create
or replace function public.get_open_limit_bets_with_contracts_1 (uid text, count integer, politics boolean) returns table (contract_id text, bets jsonb[], contract jsonb) language sql stable parallel SAFE as $function$;
select contract_id,
       bets.data as bets,
       contracts.data as contracts
from (
         select contract_id,
                array_agg(
                        data
                        order by created_time desc
                ) as data
         from contract_bets
         where user_id = uid
           and (data->>'isFilled')::boolean = false
           and (data->>'isCancelled')::boolean = false
         group by contract_id
     ) as bets
         join contracts on contracts.id = bets.contract_id
where (politics is false or is_politics = politics)
limit count $function$;

create
or replace function public.get_noob_questions () returns setof contracts language sql as $function$with newbs as (
    select id
    from users
    where created_time > now() - interval '2 weeks'
  )
  select * from contracts
  where creator_id in (select * from newbs)
  and visibility = 'public'
  order by created_time desc$function$;

create
or replace function public.get_rating (user_id text) returns table (count bigint, rating numeric) language sql immutable parallel SAFE as $function$
  WITH

  -- find average of each user's reviews
  avg_ratings AS (
    SELECT AVG(rating) AS avg_rating
    FROM reviews
    WHERE vendor_id = user_id
    GROUP BY reviewer_id
  ),

  total_count AS (
    SELECT COUNT(*) AS count
    FROM reviews
    WHERE vendor_id = user_id
  ),

  positive_counts AS (
    SELECT 5 + COUNT(*) AS count FROM avg_ratings WHERE avg_rating >= 4.0
  ),

  negative_counts AS (
    SELECT COUNT(*) AS count FROM avg_ratings WHERE avg_rating < 4.0
  ),

  -- calculate lower bound of 95th percentile confidence interval: https://www.evanmiller.org/how-not-to-sort-by-average-rating.html
  rating AS (
    SELECT (positive_counts.count + negative_counts.count) AS count,
       (
        (positive_counts.count + 1.9208) / (positive_counts.count + negative_counts.count) -
        1.96 * SQRT((positive_counts.count * negative_counts.count) / (positive_counts.count + negative_counts.count) + 0.9604) /
        (positive_counts.count + negative_counts.count)
      ) / (1 + 3.8416 / (positive_counts.count + negative_counts.count)) AS rating
    FROM positive_counts, negative_counts
  )

  SELECT total_count.count                               as count,
         -- squash with sigmoid, multiply by 5
         5 / (1 + POW(2.71828, -10*(rating.rating-0.5))) AS rating
  FROM total_count,rating;
$function$;

create
or replace function public.get_recently_active_contracts_in_group_slugs_1 (
  p_group_slugs text[],
  ignore_slugs text[],
  max integer
) returns table (data json, importance_score numeric) language sql stable parallel SAFE as $function$
select data, importance_score
from public_contracts
where (public_contracts.group_slugs && p_group_slugs)
  and not (public_contracts.group_slugs && ignore_slugs)
order by ((data->>'lastUpdatedTime')::bigint) desc
limit max
$function$;

create
or replace function public.get_recently_active_contracts_in_group_slugs_2 (
  group_slugs text[],
  ignore_slugs text[],
  max integer
) returns table (data json, importance_score numeric) language sql stable parallel SAFE as $function$
select data, importance_score
from public_contracts
where (public_contracts.data -> 'groupSlugs' ?| group_slugs)
  and not (public_contracts.data -> 'groupSlugs' ?| ignore_slugs)
order by ((data->>'lastUpdatedTime')::bigint) desc
limit max
$function$;

create
or replace function public.get_related_contracts (cid text, lim integer, start integer) returns jsonb[] language sql immutable parallel SAFE as $function$
select array_agg(data) from (
  select data
  from get_related_contract_ids(cid)
    left join contracts
    on contracts.id = contract_id
    where is_valid_contract(contracts)
  limit lim
  offset start
  ) as rel_contracts
$function$;

create
or replace function public.get_user_bets_from_resolved_contracts_rbac (uid text, count integer, start integer) returns table (contract_id text, bets jsonb[], contract jsonb) language sql immutable parallel SAFE as $function$;
select contract_id,
  bets.data as bets,
  contracts.data as contracts
from (
    select contract_id,
      array_agg(
        data
        order by (data->>'createdTime') desc
      ) as data
    from contract_bets_rbac
    where (data->>'userId') = uid
      and (data->>'amount')::real != 0
    group by contract_id
  ) as bets
  join contracts on contracts.id = bets.contract_id
where contracts.resolution_time is not null
  and contracts.outcome_type = 'BINARY'
limit count offset start $function$;

create
or replace function public.get_user_manalink_claims (creator_id text) returns table (manalink_id text, claimant_id text, ts bigint) language sql as $function$
    select mc.manalink_id, (tx.data)->>'toId' as claimant_id, ((tx.data)->'createdTime')::bigint as ts
    from manalink_claims as mc
    join manalinks as m on mc.manalink_id = m.id
    join txns as tx on mc.txn_id = tx.id
    where m.creator_id = creator_id
$function$;

create
or replace function public.get_user_portfolio_at_2023_end (p_user_id text) returns table (
  user_id text,
  ts timestamp without time zone,
  investment_value numeric,
  balance numeric,
  total_deposits numeric,
  loan_total numeric,
  id bigint
) language plpgsql as $function$
BEGIN
    RETURN QUERY
    (SELECT *
     FROM user_portfolio_history
     WHERE user_portfolio_history.user_id = p_user_id
   AND user_portfolio_history.ts < '2024-01-02'
   AND user_portfolio_history.ts > '2023-12-31'
 ORDER BY ABS(EXTRACT(EPOCH FROM (user_portfolio_history.ts - '2023-01-01'::date)))
     LIMIT 1)
    UNION ALL
    -- Query for users who created their portfolio after February 2023
    (SELECT *
     FROM user_portfolio_history
     WHERE user_portfolio_history.user_id = p_user_id
   AND user_portfolio_history.ts < '2024-01-01'
     ORDER BY user_portfolio_history.ts desc
     LIMIT 1)
    LIMIT 1;
END;
$function$;

create
or replace function public.get_reply_chain_comments_for_comment_ids (comment_ids text[]) returns table (id text, contract_id text, data jsonb) language sql as $function$
WITH matching_comments AS (
    SELECT
        c1.comment_id AS id,
        c1.contract_id,
        c1.data
    FROM
        contract_comments c1
    WHERE
            c1.comment_id = ANY(comment_ids)
),
     reply_chain_comments AS (
         SELECT
             c2.comment_id AS id,
             c2.contract_id,
             c2.data
         FROM
             contract_comments c2
                 JOIN matching_comments mc
                      ON c2.contract_id = mc.contract_id
                          AND c2.data ->> 'replyToCommentId' = mc.data ->> 'replyToCommentId'
                          AND c2.comment_id != mc.id
                          and c2.comment_id <> ALL(comment_ids)
     ),
     parent_comments AS (
         SELECT
             c3.comment_id AS id,
             c3.contract_id,
             c3.data
         FROM
             contract_comments c3
                 JOIN matching_comments mc
                      ON c3.contract_id = mc.contract_id
                          AND c3.comment_id = mc.data ->> 'replyToCommentId'
                          and c3.comment_id <> ALL(comment_ids)
     ),
     all_comments AS (
         SELECT * FROM matching_comments
         UNION ALL
         SELECT * FROM parent_comments
         UNION ALL
         SELECT * FROM reply_chain_comments
     )
SELECT DISTINCT ON (id) * FROM all_comments;
$function$;

create
or replace function public.get_reply_chain_comments_matching_contracts (contract_ids text[], past_time_ms bigint) returns table (id text, contract_id text, data jsonb) language sql as $function$
WITH matching_comments AS (
    SELECT
        c1.comment_id AS id,
        c1.contract_id,
        c1.data
    FROM
        contract_comments c1
    WHERE
            c1.contract_id = ANY(contract_ids)
      AND (c1.data -> 'createdTime')::BIGINT >= past_time_ms
),
     reply_chain_comments AS (
         SELECT
             c2.comment_id AS id,
             c2.contract_id,
             c2.data
         FROM
             contract_comments c2
                 JOIN matching_comments mc
                      ON c2.contract_id = mc.contract_id
                          AND c2.data ->> 'replyToCommentId' = mc.data ->> 'replyToCommentId'
                          AND c2.data->>'id' != mc.id
     ),
     parent_comments AS (
         SELECT
             c3.comment_id AS id,
             c3.contract_id,
             c3.data
         FROM
             contract_comments c3
                 JOIN matching_comments mc
                      ON c3.contract_id = mc.contract_id
                          AND c3.data ->> 'id' = mc.data ->> 'replyToCommentId'
     )
SELECT * FROM matching_comments
UNION ALL
SELECT * FROM parent_comments
UNION ALL
SELECT * FROM reply_chain_comments;
$function$;

create
or replace function public.get_user_bets_from_resolved_contracts (uid text, count integer, start integer) returns table (contract_id text, bets jsonb[], contract jsonb) language sql stable parallel SAFE as $function$;
select contract_id,
  bets.data as bets,
  contracts.data as contracts
from (
    select contract_id,
      array_agg(
        data
        order by created_time desc
      ) as data
    from contract_bets
    where user_id = uid
      and amount != 0
    group by contract_id
  ) as bets
  join contracts on contracts.id = bets.contract_id
where contracts.resolution_time is not null
  and contracts.outcome_type = 'BINARY'
limit count offset start $function$;

create
or replace function public.get_user_portfolio_at_2023_start (p_user_id text) returns table (
  user_id text,
  ts timestamp without time zone,
  investment_value numeric,
  balance numeric,
  total_deposits numeric,
  loan_total numeric,
  id bigint
) language plpgsql as $function$
BEGIN
    RETURN QUERY
    (SELECT *
     FROM user_portfolio_history
     WHERE user_portfolio_history.user_id = p_user_id
       AND user_portfolio_history.ts < '2023-01-02'
       AND user_portfolio_history.ts > '2022-12-31'
     ORDER BY ABS(EXTRACT(EPOCH FROM (user_portfolio_history.ts - '2023-01-01'::date)))
     LIMIT 1)
    UNION ALL
    -- Query for users who created their portfolio after February 2023
    (SELECT *
     FROM user_portfolio_history
     WHERE user_portfolio_history.user_id = p_user_id
       AND user_portfolio_history.ts >= '2023-01-02'
     ORDER BY user_portfolio_history.ts
     LIMIT 1)
    LIMIT 1;
END;
$function$;

create
or replace function public.get_your_recent_contracts (uid text, n integer, start integer) returns table (data jsonb, max_ts bigint) language sql stable parallel SAFE as $function$
  with your_bet_on_contracts as (
      select contract_id,
              (data->>'lastBetTime')::bigint as ts
      from user_contract_metrics
      where user_id = uid
        and ((data -> 'lastBetTime')::bigint) is not null
      order by ((data -> 'lastBetTime')::bigint) desc
      limit n * 10 + start * 5),
    your_liked_contracts as (
          select content_id as contract_id,
                ts_to_millis(created_time) as ts
          from user_reactions
          where user_id = uid
          order by created_time desc
          limit n * 10 + start * 5
    ),
    your_viewed_contracts as (
        select contract_id,
              ts_to_millis(last_page_view_ts) as ts
        from user_contract_views
        where user_id = uid and last_page_view_ts is not null
        order by last_page_view_ts desc
        limit n * 10 + start * 5
    ),
    recent_contract_ids as (
      select contract_id, ts
      from your_bet_on_contracts
      union all
      select contract_id, ts
      from your_viewed_contracts
      union all
      select contract_id, ts
      from your_liked_contracts
    ),
    recent_unique_contract_ids as (
      select contract_id, max(ts) AS max_ts
      from recent_contract_ids
      group by contract_id
    )
select data, max_ts
from recent_unique_contract_ids
left join contracts on contracts.id = contract_id
where data is not null
order by max_ts desc
limit n offset start $function$;

create
or replace function public.has_moderator_or_above_role (this_group_id text, this_user_id text) returns boolean language sql immutable parallel SAFE as $function$
select EXISTS (
        SELECT 1
        FROM group_members
        WHERE (
                group_id = this_group_id
                and member_id = this_user_id
                and (role='admin' or role='moderator')
            )
    ) $function$;

create
or replace function public.install_available_extensions_and_test () returns boolean language plpgsql as $function$
DECLARE extension_name TEXT;
allowed_extentions TEXT[] := string_to_array(current_setting('supautils.privileged_extensions'), ',');
BEGIN 
  FOREACH extension_name IN ARRAY allowed_extentions 
  LOOP
    SELECT trim(extension_name) INTO extension_name;
    /* skip below extensions check for now */
    CONTINUE WHEN extension_name = 'pgroonga' OR  extension_name = 'pgroonga_database' OR extension_name = 'pgsodium';
    CONTINUE WHEN extension_name = 'plpgsql' OR  extension_name = 'plpgsql_check' OR extension_name = 'pgtap';
    CONTINUE WHEN extension_name = 'supabase_vault' OR extension_name = 'wrappers';
    RAISE notice 'START TEST FOR: %', extension_name;
    EXECUTE format('DROP EXTENSION IF EXISTS %s CASCADE', quote_ident(extension_name));
    EXECUTE format('CREATE EXTENSION %s CASCADE', quote_ident(extension_name));
    RAISE notice 'END TEST FOR: %', extension_name;
  END LOOP;
    RAISE notice 'EXTENSION TESTS COMPLETED..';
    return true;
END;
$function$;

create
or replace function public.is_admin (input_string text) returns boolean language plpgsql immutable parallel SAFE as $function$
DECLARE
-- @Austin, @JamesGrugett, @SG, @DavidChee, @Alice, @ian, @IngaWei, @mqp, @Sinclair, @ManifoldPolitics, @baraki
    strings TEXT[] := ARRAY[
        'igi2zGXsfxYPgB0DJTXVJVmwCOr2',
        '5LZ4LgYuySdL1huCWe7bti02ghx2', 
        'tlmGNz9kjXc2EteizMORes4qvWl2', 
        'uglwf3YKOZNGjjEXKc5HampOFRE2', 
        'qJHrvvGfGsYiHZkGY6XjVfIMj233', 
        'AJwLWoo3xue32XIiAVrL5SyR1WB2', -- ian
        'GRwzCexe5PM6ThrSsodKZT9ziln2',
        '62TNqzdBx7X2q621HltsJm8UFht2', 
        '0k1suGSJKVUnHbCPEhHNpgZPkUP2',
        'vuI5upWB8yU00rP7yxj95J2zd952',
        'vUks7InCtYhBFrdLQhqXFUBHD4D2',
        'cA1JupYR5AR8btHUs2xvkui7jA93' -- Gen

        ];
BEGIN
    RETURN input_string = ANY(strings);
END;
$function$;

create
or replace function public.test () returns void language plpgsql as $function$
BEGIN
       RAISE LOG 'Beginning Test: %', CURRENT_TIMESTAMP;
       NOTIFY pgrst, 'reload schema';
       RAISE LOG 'Ending Test: %', CURRENT_TIMESTAMP;
       EXCEPTION
        -- Handle exceptions here if needed
       WHEN others THEN
                RAISE EXCEPTION 'An error occurred: %', SQLERRM;
END;
$function$;

create
or replace function public.pgrst_ddl_watch () returns event_trigger language plpgsql as $function$
DECLARE
  cmd record;
BEGIN
  FOR cmd IN SELECT * FROM pg_event_trigger_ddl_commands()
  LOOP
    IF cmd.command_tag IN (
      'CREATE SCHEMA', 'ALTER SCHEMA'
    , 'CREATE TABLE', 'CREATE TABLE AS', 'SELECT INTO', 'ALTER TABLE'
    , 'CREATE FOREIGN TABLE', 'ALTER FOREIGN TABLE'
    , 'CREATE VIEW', 'ALTER VIEW'
    , 'CREATE MATERIALIZED VIEW', 'ALTER MATERIALIZED VIEW'
    , 'CREATE FUNCTION', 'ALTER FUNCTION'
    , 'CREATE TRIGGER'
    , 'CREATE TYPE', 'ALTER TYPE'
    , 'CREATE RULE'
    , 'COMMENT'
    )
    -- don't notify in case of CREATE TEMP table or other objects created on pg_temp
    AND cmd.schema_name is distinct from 'pg_temp'
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$;

create
or replace function public.pgrst_drop_watch () returns event_trigger language plpgsql as $function$
DECLARE
  obj record;
BEGIN
  FOR obj IN SELECT * FROM pg_event_trigger_dropped_objects()
  LOOP
    IF obj.object_type IN (
      'schema'
    , 'table'
    , 'foreign table'
    , 'view'
    , 'materialized view'
    , 'function'
    , 'trigger'
    , 'type'
    , 'rule'
    )
    AND obj.is_temporary IS false -- no pg_temp objects
    THEN
      NOTIFY pgrst, 'reload schema';
    END IF;
  END LOOP;
END; $function$;

create
or replace function public.random_alphanumeric (length integer) returns text language plpgsql as $function$
DECLARE
  result TEXT;
BEGIN
  WITH alphanum AS (
    SELECT ARRAY['0', '1', '2', '3', '4', '5', '6', '7', '8', '9',
                 'A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J', 'K', 'L', 'M', 'N', 'O', 'P', 'Q', 'R', 'S', 'T', 'U', 'V', 'W', 'X', 'Y', 'Z',
                 'a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j', 'k', 'l', 'm', 'n', 'o', 'p', 'q', 'r', 's', 't', 'u', 'v', 'w', 'x', 'y', 'z'] AS chars
  )
  SELECT array_to_string(ARRAY (
    SELECT alphanum.chars[1 + floor(random() * 62)::integer]
    FROM alphanum, generate_series(1, length)
  ), '') INTO result;

  RETURN result;
END;
$function$;

create
or replace function public.save_user_topic_2 (p_user_id text, p_topics text[]) returns void language sql as $function$
with topic_embedding as (
    select avg(embedding) as average
    from topic_embeddings
    where topic = any(p_topics)
)
insert into user_topics (user_id, topics, topic_embedding)
values (
           p_user_id,
           p_topics,
           (
               select average
               from topic_embedding
           )
       ) on conflict (user_id) do
    update
    set topics = excluded.topics,
        topic_embedding = excluded.topic_embedding;
$function$;

create
or replace function public.save_user_topics (p_user_id text, p_topics text[]) returns void language sql as $function$
with topic_embedding as (
    select avg(embedding) as average
    from topic_embeddings
    where topic = any(p_topics)
)
insert into user_topics (user_id, topics, topic_embedding)
values (
           p_user_id,
           p_topics,
           (
               select average
               from topic_embedding
           )
       ) on conflict (user_id) do
    update
    set topics = excluded.topics,
        topic_embedding = excluded.topic_embedding;
$function$;

create
or replace function public.save_user_topics_2 (p_user_id text, p_topics text[]) returns void language sql as $function$
with topic_embedding as (
    select avg(embedding) as average
    from topic_embeddings
    where topic = any(p_topics)
)
insert into user_topics (user_id, topics, topic_embedding)
values (
           p_user_id,
           p_topics,
           (
               select average
               from topic_embedding
           )
       ) on conflict (user_id) do
    update
    set topics = excluded.topics,
        topic_embedding = excluded.topic_embedding;
$function$;

create
or replace function public.save_user_topics_blank (p_user_id text) returns void language sql as $function$
with
    topic_embedding as (
        select avg(embedding) as average
        from topic_embeddings where topic not in (
            select unnest(ARRAY['destiny.gg', 'stock', 'planecrash', 'proofnik', 'permanent', 'personal']::text[])
        )
    )
insert into user_topics (user_id, topics, topic_embedding)
values (
           p_user_id,
           ARRAY['']::text[],
           (
               select average
               from topic_embedding
           )
       ) on conflict (user_id) do
    update set topics = excluded.topics,
               topic_embedding = excluded.topic_embedding;
$function$;

create
or replace function public.save_user_topics_blank2 (p_user_id text) returns void language sql as $function$
with
    average_all as (
        select avg(embedding) as average
        from topic_embeddings
    ),
    ignore_embeddings as (
    select avg(embedding) as average
    from topic_embeddings
    where topic in (
        select unnest(ARRAY['destiny.gg', 'stock','planecrash', 'proof school', 'personal']::text[])
    )
    ),
    topic_embedding as (
    select (avg_all.average - not_chosen.average) as average
    from average_all as avg_all,
         ignore_embeddings as not_chosen
    )
insert into user_topics (user_id, topics, topic_embedding)
values (
           p_user_id,
           ARRAY['']::text[],
           (
               select average
               from topic_embedding
           )
       ) on conflict (user_id) do
    update set topics = excluded.topics,
               topic_embedding = excluded.topic_embedding;
$function$;

create
or replace function public.search_contracts_test (
  term text,
  contract_filter text,
  contract_sort text,
  offset_n integer,
  limit_n integer,
  fuzzy boolean default false,
  group_id text default null::text,
  creator_id text default null::text
) returns text language plpgsql as $function$
DECLARE base_query TEXT;
where_clause TEXT;
sql_query TEXT;
BEGIN -- Common WHERE clause
-- If fuzzy search is enabled and is group search
IF group_id is not null
and fuzzy then base_query := FORMAT(
  '
      SELECT contractz.data
      FROM (
        SELECT contracts_rbac.*,
               similarity(contracts_rbac.question, %L) AS similarity_score,
               group_contracts.group_id
        FROM contracts_rbac join group_contracts on group_contracts.contract_id = contracts_rbac.id
      ) AS contractz
      %s
      AND contractz.similarity_score > 0.1
      AND contractz.group_id = %L',
  term,
  generate_where_query(contract_filter, contract_sort, creator_id),
  group_id
);
-- If full text search is enabled and is group search
ELSIF group_id is not null then base_query := FORMAT(
  '
SELECT contractz.data
FROM (select contracts_rbac.*, group_contracts.group_id from contracts_rbac join group_contracts on group_contracts.contract_id = contracts_rbac.id) as contractz,
  websearch_to_tsquery('' english '', %L) query
      %s
AND contractz.question_fts @@ query
AND contractz.group_id = %L',
  term,
  generate_where_query(contract_filter, contract_sort, creator_id),
  group_id
);
-- If fuzzy search is enabled
ELSIF fuzzy THEN base_query := FORMAT(
  '
      SELECT contractz.data
      FROM (
        SELECT contracts_rbac.*,
               similarity(contracts_rbac.question, %L) AS similarity_score
        FROM contracts_rbac
      ) AS contractz
      %s
      AND contractz.similarity_score > 0.1',
  term,
  generate_where_query(contract_filter, contract_sort, creator_id)
);
-- If full text search is enabled
ELSE base_query := FORMAT(
  '
      SELECT contracts_rbac.data
      FROM contracts_rbac, websearch_to_tsquery(''english'', %L) query
      %s
      AND contracts_rbac.question_fts @@ query',
  term,
  generate_where_query(contract_filter, contract_sort, creator_id)
);
END IF;
sql_query := FORMAT(
  '
    %s
    %s',
  base_query,
  generate_sort_query(contract_sort, fuzzy, offset_n, limit_n)
);
RETURN sql_query;
END;
$function$;

create
or replace function public.search_contracts_combined (
  term text,
  contract_filter text,
  contract_sort text,
  offset_n integer,
  limit_n integer,
  fuzzy boolean default false,
  groupid text default null::text
) returns table (data jsonb) language plpgsql as $function$
DECLARE
  base_query TEXT;
BEGIN
  base_query := '
    WITH group_filtered_contracts AS (
      SELECT contracts_rbac.*
      FROM contracts_rbac
      ' || (CASE WHEN groupId IS NOT NULL THEN
        'JOIN group_contracts ON contracts_rbac.id = group_contracts.contract_id WHERE group_contracts.group_id = ' || quote_literal(groupId)
      ELSE
        ''
      END) || '
    ),
    search_filtered_contracts AS (
      SELECT *
      FROM group_filtered_contracts
      WHERE
      ' || (CASE WHEN fuzzy THEN
        'group_filtered_contracts.question_fts @@ websearch_to_tsquery(''english'', term) AND similarity(group_filtered_contracts.question, term) > 0.1'
      ELSE
        'group_filtered_contracts.question_fts @@ websearch_to_tsquery(''english'', term)'
      END) || '
    )
    SELECT search_filtered_contracts.data
    FROM search_filtered_contracts
    WHERE (
      (contract_filter = ''open'' AND search_filtered_contracts.resolution_time IS NULL)
      OR (contract_filter = ''closed'' AND search_filtered_contracts.close_time <  NOW() and search_filtered_contracts.resolution_time IS NULL)
      OR (contract_filter = ''resolved'' AND search_filtered_contracts.resolution_time IS NOT NULL)
      OR (contract_filter = ''all'')
    )
    AND (contract_sort != ''close-date'' OR (contract_sort = ''close-date'' AND search_filtered_contracts.close_time > NOW()))
    ORDER BY
      CASE contract_sort
        WHEN ''relevance'' THEN
          CASE
            WHEN fuzzy THEN similarity(search_filtered_contracts.question, term)
            ELSE ts_rank_cd(search_filtered_contracts.question_fts, websearch_to_tsquery(''english'', term))
          END
        WHEN ''score'' THEN search_filtered_contracts.popularity_score
        WHEN ''daily-score'' THEN (search_filtered_contracts.data->>''dailyScore'')::numeric
        WHEN ''24-hour-vol'' THEN (search_filtered_contracts.data->>''volume24Hours'')::numeric
        WHEN ''liquidity'' THEN (search_filtered_contracts.data->>''elasticity'')::numeric
        WHEN ''last-updated'' THEN (search_filtered_contracts.data->>''lastUpdatedTime'')::numeric
        END DESC NULLS LAST,
      CASE contract_sort
        WHEN ''most-popular'' THEN (search_filtered_contracts.data->>''uniqueBettorCount'')::integer
        END DESC NULLS LAST,
      CASE contract_sort
        WHEN ''newest'' THEN search_filtered_contracts.created_time
        WHEN ''resolve-date'' THEN search_filtered_contracts.resolution_time
        END DESC NULLS LAST,
      CASE WHEN contract_sort = ''close-date'' THEN search_filtered_contracts.close_time END ASC NULLS LAST
    OFFSET ' || offset_n || '
    LIMIT ' || limit_n || '
  ';

  RETURN QUERY EXECUTE base_query;
END;
$function$;

create
or replace function public.search_group_embeddings (
  query_embedding vector,
  similarity_threshold double precision,
  max_count integer,
  name_similarity_threshold double precision
) returns table (
  name text,
  group_id text,
  similarity double precision
) language sql as $function$
with groups_similar_to_news as (
    select name,
        group_id,
           1 - (group_embeddings.embedding <=> query_embedding) as similarity,
           row_number() over (order by (group_embeddings.embedding <=> query_embedding)) as row_num
    from group_embeddings
             left join groups on groups.id = group_embeddings.group_id
    where 1 - (
            group_embeddings.embedding <=> query_embedding
        ) > similarity_threshold
    order by group_embeddings.embedding <=> query_embedding
    limit max_count*2
),
     filtered_groups as (
         select
             g1.*
         from
             groups_similar_to_news as g1
         where not exists (
             select 1
             from groups_similar_to_news as g2
             where g1.row_num > g2.row_num
               and similarity(g1.name, g2.name) > name_similarity_threshold
         )
     )
select name, group_id, similarity from filtered_groups
order by similarity desc
limit max_count;
$function$;

create
or replace function public.test_search_contracts (
  term text,
  contract_filter text,
  contract_sort text,
  offset_n integer,
  limit_n integer,
  fuzzy boolean default false,
  group_id text default null::text,
  creator_id text default null::text
) returns text language plpgsql as $function$
DECLARE base_query TEXT;
where_clause TEXT;
sql_query TEXT;
BEGIN -- Common WHERE clause
-- If fuzzy search is enabled and is group search
IF group_id is not null
and fuzzy then base_query := FORMAT(
    '
      SELECT contractz.data
      FROM (
        SELECT contracts_rbac.*,
               similarity(contracts_rbac.question, %L) AS similarity_score,
               group_contracts.group_id
        FROM contracts_rbac join group_contracts on group_contracts.contract_id = contracts_rbac.id
      ) AS contractz
      %s
      AND contractz.similarity_score > 0.1
      AND contractz.group_id = %L',
    term,
    generate_where_query(contract_filter, contract_sort, creator_id),
    group_id
);
-- If full text search is enabled and is group search
ELSIF group_id is not null then base_query := FORMAT(
    '
SELECT contractz.data
FROM (select contracts_rbac.*, group_contracts.group_id from contracts_rbac join group_contracts on group_contracts.contract_id = contracts_rbac.id) as contractz,
  websearch_to_tsquery('' english '', %L) query
      %s
AND contractz.question_fts @@ query
AND contractz.group_id = %L',
    term,
    generate_where_query(contract_filter, contract_sort, creator_id),
    group_id
);
-- If fuzzy search is enabled
ELSIF fuzzy THEN base_query := FORMAT(
    '
      SELECT contractz.data
      FROM (
        SELECT contracts_rbac.*,
               similarity(contracts_rbac.question, %L) AS similarity_score
        FROM contracts_rbac
      ) AS contractz
      %s
      AND contractz.similarity_score > 0.1',
    term,
    generate_where_query(contract_filter, contract_sort, creator_id)
);
-- If full text search is enabled
ELSE base_query := FORMAT(
    '
      SELECT contracts_rbac.data
      FROM contracts_rbac, websearch_to_tsquery(''english'', %L) query
      %s
      AND contracts_rbac.question_fts @@ query',
    term,
    generate_where_query(contract_filter, contract_sort, creator_id)
);
END IF;
sql_query := FORMAT(
    '
    %s
    %s',
    base_query,
    generate_sort_query(contract_sort, fuzzy, offset_n, limit_n)
);
RETURN sql_query;
END;
$function$;

create
or replace function public.test_empty_search_contracts (
  contract_filter text,
  contract_sort text,
  offset_n integer,
  limit_n integer,
  group_id text default null::text,
  creator_id text default null::text
) returns text language plpgsql as $function$
DECLARE base_query TEXT;
where_clause TEXT;
sql_query TEXT;
BEGIN -- Common WHERE clause
-- If fuzzy search is enabled and is group search
IF group_id is not null then base_query := FORMAT(
  '
SELECT contractz.data
FROM (select contracts_rbac.*, group_contracts.group_id from contracts_rbac join group_contracts on group_contracts.contract_id = contracts_rbac.id) as contractz
      %s
AND contractz.group_id = %L',
  generate_where_query(contract_filter, contract_sort, creator_id),
  group_id
);
-- If full text search is enabled
ELSE base_query := FORMAT(
  '
  SELECT contracts_rbac.data
  FROM contracts_rbac 
    %s',
  generate_where_query(contract_filter, contract_sort, creator_id)
);
END IF;
sql_query := FORMAT(
  ' %s %s ',
  base_query,
  generate_sort_query(contract_sort, TRUE, offset_n, limit_n, TRUE)
);
RETURN sql_query;
END;
$function$;

create
or replace function public.top_creators_for_user (uid text, excluded_ids text[], limit_n integer) returns table (user_id text, n double precision) language sql stable parallel SAFE as $function$
  select c.creator_id as user_id, count(*) as n
  from contract_bets as cb
  join contracts as c on c.id = cb.contract_id
  where cb.user_id = uid and not c.creator_id = any(excluded_ids)
  group by c.creator_id
  order by count(*) desc
  limit limit_n
$function$;

create
or replace function public.top_news (uid text) returns table (title text, description text) language sql as $function$
with 
user_embedding as (
  select interest_embedding
  from user_embeddings
  where user_id = uid
)
  SELECT
    title, description
  FROM
    news
  where
    1 - (title_embedding <=> (select interest_embedding from user_embedding)) > 0.7
  ORDER BY published_time DESC
  LIMIT 1000;
$function$;

create
or replace function public.user_top_news (uid text, similarity numeric, n numeric) returns table (
  id numeric,
  created_time timestamp without time zone,
  title text,
  url text,
  published_time timestamp without time zone,
  author text,
  description text,
  image_url text,
  source_id text,
  source_name text,
  contract_ids text[]
) language sql as $function$
with 
user_embedding as (
  select interest_embedding
  from user_embeddings
  where user_id = uid
)
  SELECT
    id, created_time, title, url, published_time, author, description, image_url, source_id, source_name, contract_ids
  FROM
    news
  where
    1 - (title_embedding <=> (select interest_embedding from user_embedding)) > similarity
  ORDER BY published_time DESC
  LIMIT n;
$function$;

create
or replace function public.get_related_contracts_by_group (p_contract_id text, lim integer, start integer) returns table (data jsonb) language sql stable parallel SAFE as $function$
select distinct on (other_contracts.importance_score, other_contracts.slug) other_contracts.data
from contracts
     join group_contracts on contracts.id = group_contracts.contract_id
     join contracts as other_contracts on other_contracts.id in (
    select gc.contract_id
    from group_contracts gc
    where gc.group_id in (
        select group_id
        from group_contracts
        where contract_id = p_contract_id
    )
)
where contracts.id = p_contract_id
  and is_valid_contract(other_contracts)
  and other_contracts.id != p_contract_id
order by other_contracts.importance_score desc, other_contracts.slug
offset start limit lim
$function$;

create
or replace function public.get_related_contracts_by_group_and_creator (p_contract_id text, lim integer, start integer) returns table (data jsonb) language sql stable parallel SAFE as $function$
select distinct on (other_contracts.importance_score, other_contracts.slug) other_contracts.data
from contracts
         join group_contracts on contracts.id = group_contracts.contract_id
         join contracts as other_contracts on other_contracts.id in (
    select gc.contract_id
    from group_contracts gc
    where gc.group_id in (
        select group_id
        from group_contracts
        where contract_id = p_contract_id
    )
)
where contracts.id = p_contract_id
  and is_valid_contract(other_contracts)
  and other_contracts.id != p_contract_id
  and other_contracts.creator_id = contracts.creator_id
order by other_contracts.importance_score desc, other_contracts.slug
offset start limit lim
$function$;

create
or replace function public.get_user_topic_interests_2 (p_user_id text) returns table (group_id text, score numeric) language plpgsql as $function$
begin
    return query
        select
            kv.key as group_id,
            coalesce((kv.value->>'conversionScore')::numeric, 0.0) as score
        from (
                 select group_ids_to_activity
                 from user_topic_interests
                 where user_id = p_user_id
                 order by created_time desc
                 limit 1
             ) as latest_record,
             jsonb_each(latest_record.group_ids_to_activity) as kv
        order by score desc;
end;
$function$;

create
or replace function public.search_contract_embeddings_1 (
  query_embedding vector,
  similarity_threshold double precision,
  match_count integer
) returns table (contract_id text, similarity double precision) language plpgsql as $function$
begin
    return query
        select contract_embeddings.contract_id as contract_id,
               (contract_embeddings.embedding <#> query_embedding) as similarity
        from contract_embeddings
        where (contract_embeddings.embedding <#> query_embedding) < -1 * similarity_threshold
        order by (contract_embeddings.embedding <#> query_embedding)
        limit match_count;
end;
$function$;

create
or replace function public.profit_leaderboard (limit_n integer) returns table (
  user_id text,
  profit numeric,
  name text,
  username text,
  avatar_url text
) language sql stable parallel SAFE as $function$
select p.user_id, coalesce(p.profit, p.balance + p.spice_balance + p.investment_value - p.total_deposits) as profit, u.name, u.username, u.data->>'avatarUrl' as avatar_url
from user_portfolio_history_latest p join users u on p.user_id = u.id
order by profit desc
limit limit_n
$function$;

create
or replace function public.get_user_topic_interests (p_user_id text, limit_rows integer) returns table (
  group_id text,
  avg_conversion_score numeric,
  groups_count bigint
) language plpgsql as $function$ begin return query
    with interests_array as (
        select group_ids_to_activity
        from user_topic_interests
        where user_topic_interests.user_id = p_user_id
        order by created_time desc
        limit limit_rows
    ), unnested_objects as (
        select jsonb_array_elements(jsonb_agg(group_ids_to_activity)) as group_ids_to_activity
        from interests_array
    ), key_value_pairs as (
        select key, value
        from unnested_objects
         cross join lateral jsonb_each(group_ids_to_activity) as kv(key, value)
    )
    select
        key as group_id,
        avg(coalesce((value->>'conversionScore')::numeric, 0.0)) as avg_conversion_score,
        count(*) as groups_count
    from key_value_pairs
    group by group_id
    order by avg_conversion_score desc, groups_count desc;
end; $function$;

create
or replace function public.get_user_topic_interests_1 (p_user_id text, limit_rows integer) returns table (
  group_id text,
  avg_conversion_score numeric,
  groups_count bigint
) language plpgsql as $function$ begin return query
    with interests_array as (
        select group_ids_to_activity, created_time
        from user_topic_interests
        where user_topic_interests.user_id = p_user_id
        order by created_time desc
        limit limit_rows
    ), unnested_objects as (
        select jsonb_array_elements(jsonb_agg(jsonb_build_object('group_ids_to_activity', group_ids_to_activity, 'created_time', created_time))) as obj
        from interests_array
    ), key_value_pairs as (
        select key, value, row_number() over (partition by key order by (obj->>'created_time')::timestamp desc) as position
        from unnested_objects
                 cross join lateral jsonb_each(obj->'group_ids_to_activity') as kv(key, value)
    ), decay_factors as (
        select key, value, greatest(1.0 - 0.01 * (position - 1),0.01) as decay_factor
        from key_value_pairs
    )
    select
        key as group_id,
        sum(coalesce((value->>'conversionScore')::numeric, 0.0) * decay_factor) / count(decay_factor) as avg_conversion_score,
        count(*) as groups_count
    from decay_factors
    group by group_id
    order by avg_conversion_score desc, groups_count desc;
end; $function$;
