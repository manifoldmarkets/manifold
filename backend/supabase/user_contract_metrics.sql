-- This file is autogenerated from regen-schema.ts

CREATE TABLE IF NOT EXISTS user_contract_metrics (
  answer_id text,
  contract_id text NOT NULL,
  data jsonb NOT NULL,
  has_no_shares boolean,
  has_shares boolean,
  has_yes_shares boolean,
  id bigint PRIMARY KEY GENERATED ALWAYS AS IDENTITY NOT NULL,
  loan numeric DEFAULT 0 NOT NULL,
  profit numeric,
  profit_adjustment numeric,
  total_shares_no numeric,
  total_shares_yes numeric,
  user_id text NOT NULL
);


-- Triggers
CREATE TRIGGER update_null_answer_metrics_trigger AFTER INSERT OR UPDATE ON public.user_contract_metrics FOR EACH ROW EXECUTE FUNCTION update_null_answer_metrics();

-- Functions
CREATE OR REPLACE FUNCTION public.update_null_answer_metrics()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
DECLARE
    sum_has_yes_shares BOOLEAN := FALSE;
    sum_has_no_shares BOOLEAN := FALSE;
    sum_has_shares BOOLEAN := FALSE;
    sum_loan NUMERIC := 0;
BEGIN
    -- Check if the new row has a non-null answer_id
    IF NEW.answer_id IS NOT NULL THEN
        -- Aggregate boolean fields and loan from rows with the same user_id and contract_id
        SELECT
            BOOL_OR(has_yes_shares),
            BOOL_OR(has_no_shares),
            BOOL_OR(has_shares),
            COALESCE(SUM(loan), 0)
        INTO
            sum_has_yes_shares,
            sum_has_no_shares,
            sum_has_shares,
            sum_loan
        FROM user_contract_metrics
        WHERE user_id = NEW.user_id
          AND contract_id = NEW.contract_id
          AND answer_id IS NOT NULL;
        -- Update the row where answer_id is null with the aggregated metrics
        UPDATE user_contract_metrics
        SET
            data = data || jsonb_build_object(
                    'hasYesShares', sum_has_yes_shares,
                    'hasNoShares', sum_has_no_shares,
                    'hasShares', sum_has_shares,
                    'loan', sum_loan
                           ),
            has_yes_shares = sum_has_yes_shares,
            has_no_shares = sum_has_no_shares,
            has_shares = sum_has_shares,
            loan = sum_loan
        WHERE user_id = NEW.user_id
          AND contract_id = NEW.contract_id
          AND answer_id IS NULL;
    END IF;

    RETURN NEW;
END;
$function$
;

-- Row Level Security
ALTER TABLE user_contract_metrics ENABLE ROW LEVEL SECURITY;
-- Policies
DROP POLICY IF EXISTS "public read" ON user_contract_metrics;
CREATE POLICY "public read" ON user_contract_metrics FOR SELECT USING (true) ;

DROP POLICY IF EXISTS "read for admin" ON user_contract_metrics;
CREATE POLICY "read for admin" ON user_contract_metrics FOR SELECT TO service_role USING (true) ;

-- Indexes
DROP INDEX IF EXISTS contract_metrics_answer_id;
CREATE INDEX contract_metrics_answer_id ON public.user_contract_metrics USING btree (contract_id, answer_id);
DROP INDEX IF EXISTS unique_user_contract_answer;
CREATE UNIQUE INDEX unique_user_contract_answer ON public.user_contract_metrics USING btree (user_id, contract_id, COALESCE(answer_id, ''::text));
DROP INDEX IF EXISTS user_contract_metrics_contract_profit_null;
CREATE INDEX user_contract_metrics_contract_profit_null ON public.user_contract_metrics USING btree (contract_id, profit) WHERE (answer_id IS NULL);
DROP INDEX IF EXISTS user_contract_metrics_pkey;
CREATE UNIQUE INDEX user_contract_metrics_pkey ON public.user_contract_metrics USING btree (id);
DROP INDEX IF EXISTS user_contract_metrics_recent_bets;
CREATE INDEX user_contract_metrics_recent_bets ON public.user_contract_metrics USING btree (user_id, (((data -> 'lastBetTime'::text))::bigint) DESC);

