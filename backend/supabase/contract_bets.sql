-- This file is autogenerated from regen-schema.ts

CREATE TABLE IF NOT EXISTS contract_bets (
  amount numeric,
  answer_id text,
  bet_id text PRIMARY KEY DEFAULT random_alphanumeric(12) NOT NULL,
  contract_id text NOT NULL,
  created_time timestamp with time zone DEFAULT now() NOT NULL,
  data jsonb NOT NULL,
  is_api boolean,
  is_cancelled boolean,
  is_filled boolean,
  is_redemption boolean,
  loan_amount numeric,
  outcome text,
  prob_after numeric,
  prob_before numeric,
  shares numeric,
  updated_time timestamp with time zone DEFAULT now() NOT NULL,
  user_id text NOT NULL
);


-- Triggers
CREATE TRIGGER contract_bet_populate BEFORE INSERT OR UPDATE ON public.contract_bets FOR EACH ROW EXECUTE FUNCTION contract_bet_populate_cols();
CREATE TRIGGER contract_bet_update AFTER UPDATE ON public.contract_bets FOR EACH ROW EXECUTE FUNCTION contract_bet_set_updated_time();

-- Functions
CREATE OR REPLACE FUNCTION public.contract_bet_populate_cols()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    if new.bet_id is not null then
        new.data := new.data || jsonb_build_object('id', new.bet_id);
    end if;
    if new.updated_time is null and new.created_time is not null then
        new.updated_time := new.created_time;
    end if;
    if new.data is not null then
        new.user_id := (new.data) ->> 'userId';
        new.amount := ((new.data) ->> 'amount')::numeric;
        new.shares := ((new.data) ->> 'shares')::numeric;
        new.outcome := ((new.data) ->> 'outcome');
        new.prob_before := ((new.data) ->> 'probBefore')::numeric;
        new.prob_after := ((new.data) ->> 'probAfter')::numeric;
        new.is_redemption := ((new.data) -> 'isRedemption')::boolean;
        new.answer_id := ((new.data) ->> 'answerId')::text;
        new.is_api := ((new.data) ->> 'isApi')::boolean;
        new.loan_amount := ((new.data) ->> 'loanAmount')::numeric;
        new.is_filled := ((new.data) ->> 'isFilled')::boolean;
        new.is_cancelled := ((new.data) ->> 'isCancelled')::boolean;
    end if;
    return new;
end
$function$
;

CREATE OR REPLACE FUNCTION public.contract_bet_set_updated_time()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
    new.updated_time = now();
    return new;
end;
$function$
;

-- Row Level Security
ALTER TABLE contract_bets ENABLE ROW LEVEL SECURITY;
-- Indexes
DROP INDEX IF EXISTS contract_bets_contract_limit_orders;
CREATE INDEX contract_bets_contract_limit_orders ON public.contract_bets USING btree (contract_id, is_filled, is_cancelled, is_redemption, created_time DESC);
DROP INDEX IF EXISTS contract_bets_contract_user_id;
CREATE INDEX contract_bets_contract_user_id ON public.contract_bets USING btree (contract_id, user_id, created_time DESC);
DROP INDEX IF EXISTS contract_bets_created_time;
CREATE INDEX contract_bets_created_time ON public.contract_bets USING btree (contract_id, created_time DESC);
DROP INDEX IF EXISTS contract_bets_created_time_only;
CREATE INDEX contract_bets_created_time_only ON public.contract_bets USING btree (created_time DESC);
DROP INDEX IF EXISTS contract_bets_historical_probs_non_redemption;
CREATE INDEX contract_bets_historical_probs_non_redemption ON public.contract_bets USING btree (contract_id, answer_id, created_time DESC) INCLUDE (prob_before, prob_after) WHERE (NOT is_redemption);
DROP INDEX IF EXISTS contract_bets_pkey;
CREATE UNIQUE INDEX contract_bets_pkey ON public.contract_bets USING btree (bet_id);
DROP INDEX IF EXISTS contract_bets_user_id_created_time;
CREATE INDEX contract_bets_user_id_created_time ON public.contract_bets USING btree (user_id, created_time DESC);
DROP INDEX IF EXISTS contract_bets_user_outstanding_limit_orders;
CREATE INDEX contract_bets_user_outstanding_limit_orders ON public.contract_bets USING btree (user_id, is_filled, is_cancelled);

