-- This file is autogenerated from regen-schema.ts

CREATE TABLE IF NOT EXISTS contracts (
  close_time timestamp with time zone,
  conversion_score numeric DEFAULT 0 NOT NULL,
  created_time timestamp with time zone,
  creator_id text,
  daily_score numeric DEFAULT 0 NOT NULL,
  data jsonb NOT NULL,
  deleted boolean DEFAULT false,
  description_fts tsvector GENERATED ALWAYS AS (to_tsvector('english_extended'::regconfig, add_creator_name_to_description(data))) STORED,
  freshness_score numeric DEFAULT 0 NOT NULL,
  group_slugs text[],
  id text PRIMARY KEY NOT NULL,
  importance_score numeric DEFAULT 0 NOT NULL,
  is_spice_payout boolean DEFAULT false,
  last_bet_time timestamp with time zone,
  last_comment_time timestamp with time zone,
  last_updated_time timestamp with time zone,
  mechanism text,
  outcome_type text,
  popularity_score numeric DEFAULT 0 NOT NULL,
  question text,
  question_fts tsvector GENERATED ALWAYS AS (to_tsvector('english_extended'::regconfig, question)) STORED,
  question_nostop_fts tsvector GENERATED ALWAYS AS (to_tsvector('english_nostop_with_prefix'::regconfig, question)) STORED,
  resolution text,
  resolution_probability numeric,
  resolution_time timestamp with time zone,
  slug text,
  tier text,
  token text DEFAULT 'MANA'::character varying NOT NULL CONSTRAINT contracts_token_check CHECK ((token = ANY (ARRAY[('MANA'::character varying)::text, ('CASH'::character varying)::text]))),
  unique_bettor_count bigint DEFAULT 0 NOT NULL,
  view_count bigint DEFAULT 0 NOT NULL,
  visibility text
);


-- Triggers
CREATE TRIGGER contract_populate BEFORE INSERT OR UPDATE ON public.contracts FOR EACH ROW EXECUTE FUNCTION contract_populate_cols();
CREATE TRIGGER sync_sibling_contract_trigger AFTER UPDATE ON public.contracts FOR EACH ROW EXECUTE FUNCTION sync_sibling_contract();

-- Functions
CREATE OR REPLACE FUNCTION public.contract_populate_cols()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if new.data is not null then
  new.slug := (new.data) ->> 'slug';
  new.question := (new.data) ->> 'question';
  new.creator_id := (new.data) ->> 'creatorId';
  new.visibility := (new.data) ->> 'visibility';
  new.mechanism := (new.data) ->> 'mechanism';
  new.outcome_type := (new.data) ->> 'outcomeType';
  new.unique_bettor_count := ((new.data) -> 'uniqueBettorCount')::bigint;
  new.tier := (new.data) ->> 'marketTier';
  new.created_time := case
      when new.data ? 'createdTime' then millis_to_ts(((new.data) ->> 'createdTime')::bigint)
      else null
    end;
  new.close_time := case
      when new.data ? 'closeTime' then millis_to_ts(((new.data) ->> 'closeTime')::bigint)
      else null
    end;
  new.resolution_time := case
      when new.data ? 'resolutionTime' then millis_to_ts(((new.data) ->> 'resolutionTime')::bigint)
      else null
    end;
  new.resolution_probability := ((new.data) ->> 'resolutionProbability')::numeric;
  new.resolution := (new.data) ->> 'resolution';
  new.is_spice_payout := coalesce(((new.data) ->> 'isSpicePayout')::boolean, false);
  new.popularity_score := coalesce(((new.data) ->> 'popularityScore')::numeric, 0);
  new.deleted := coalesce(((new.data) ->> 'deleted')::boolean, false);
  new.group_slugs := case
      when new.data ? 'groupSlugs' then jsonb_array_to_text_array((new.data) -> 'groupSlugs')
      else null
    end;
  new.last_updated_time := case
      when new.data ? 'lastUpdatedTime' then millis_to_ts(((new.data) ->> 'lastUpdatedTime')::bigint)
      else null
    end;
  new.last_bet_time := case
      when new.data ? 'lastBetTime' then millis_to_ts(((new.data) ->> 'lastBetTime')::bigint)
      else null
    end;
  new.last_comment_time := case
      when new.data ? 'lastCommentTime' then millis_to_ts(((new.data) ->> 'lastCommentTime')::bigint)
      else null
    end;
  end if;
  return new;
end
$function$
;

CREATE OR REPLACE FUNCTION public.sync_sibling_contract()
 RETURNS trigger
 LANGUAGE plpgsql
AS $function$
begin
  if new.token = 'MANA' and (new.data->>'siblingContractId') is not null
    and (
      old.data->>'closeTime' != new.data->>'closeTime'
      or old.data->>'deleted' != new.data->>'deleted'
      or old.data->>'question' != new.data->>'question'
    ) then
  update contracts
  set data = data || jsonb_build_object(
    'closeTime', new.data->'closeTime',
    'deleted', new.data->'deleted',
    'question', new.data->'question'
  )
  where id = (new.data->>'siblingContractId')::text;
  end if;
  return new;
end;
$function$
;

-- Row Level Security
ALTER TABLE contracts ENABLE ROW LEVEL SECURITY;
-- Policies
DROP POLICY IF EXISTS "public read" ON contracts;
CREATE POLICY "public read" ON contracts FOR SELECT USING (true) ;

-- Indexes
DROP INDEX IF EXISTS contracts_close_time;
CREATE INDEX contracts_close_time ON public.contracts USING btree (close_time DESC);
DROP INDEX IF EXISTS contracts_created_time;
CREATE INDEX contracts_created_time ON public.contracts USING btree (created_time DESC);
DROP INDEX IF EXISTS contracts_creator_id;
CREATE INDEX contracts_creator_id ON public.contracts USING btree (creator_id, created_time);
DROP INDEX IF EXISTS contracts_daily_score;
CREATE INDEX contracts_daily_score ON public.contracts USING btree (daily_score DESC);
DROP INDEX IF EXISTS contracts_elasticity;
CREATE INDEX contracts_elasticity ON public.contracts USING btree ((((data ->> 'elasticity'::text))::numeric) DESC);
DROP INDEX IF EXISTS contracts_freshness_score;
CREATE INDEX contracts_freshness_score ON public.contracts USING btree (freshness_score DESC);
DROP INDEX IF EXISTS contracts_group_slugs_importance;
CREATE INDEX contracts_group_slugs_importance ON public.contracts USING gin (group_slugs, importance_score);
DROP INDEX IF EXISTS contracts_importance_score;
CREATE INDEX contracts_importance_score ON public.contracts USING btree (importance_score DESC);
DROP INDEX IF EXISTS contracts_last_bet_time;
CREATE INDEX contracts_last_bet_time ON public.contracts USING btree (last_bet_time DESC NULLS LAST);
DROP INDEX IF EXISTS contracts_last_comment_time;
CREATE INDEX contracts_last_comment_time ON public.contracts USING btree (last_comment_time DESC NULLS LAST);
DROP INDEX IF EXISTS contracts_last_updated_time;
CREATE INDEX contracts_last_updated_time ON public.contracts USING btree (last_updated_time DESC NULLS LAST);
DROP INDEX IF EXISTS contracts_outcome_type_binary;
CREATE INDEX contracts_outcome_type_binary ON public.contracts USING btree (outcome_type) WHERE (outcome_type = 'BINARY'::text);
DROP INDEX IF EXISTS contracts_outcome_type_not_binary;
CREATE INDEX contracts_outcome_type_not_binary ON public.contracts USING btree (outcome_type) WHERE (outcome_type <> 'BINARY'::text);
DROP INDEX IF EXISTS contracts_pkey;
CREATE UNIQUE INDEX contracts_pkey ON public.contracts USING btree (id);
DROP INDEX IF EXISTS contracts_resolution_time;
CREATE INDEX contracts_resolution_time ON public.contracts USING btree (resolution_time DESC);
DROP INDEX IF EXISTS contracts_slug;
CREATE INDEX contracts_slug ON public.contracts USING btree (slug);
DROP INDEX IF EXISTS contracts_visibility_public;
CREATE INDEX contracts_visibility_public ON public.contracts USING btree (id) WHERE (visibility = 'public'::text);
DROP INDEX IF EXISTS contracts_volume_24_hours;
CREATE INDEX contracts_volume_24_hours ON public.contracts USING btree ((((data ->> 'volume24Hours'::text))::numeric) DESC);
DROP INDEX IF EXISTS description_fts;
CREATE INDEX description_fts ON public.contracts USING gin (description_fts);
DROP INDEX IF EXISTS market_token_tier_idx;
CREATE INDEX market_token_tier_idx ON public.contracts USING btree (token, tier);
DROP INDEX IF EXISTS question_fts;
CREATE INDEX question_fts ON public.contracts USING gin (question_fts);
DROP INDEX IF EXISTS question_nostop_fts;
CREATE INDEX question_nostop_fts ON public.contracts USING gin (question_nostop_fts);

